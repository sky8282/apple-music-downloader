package downloader

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"main/internal/api"
	"main/internal/core"
	"main/internal/metadata"
	"main/internal/parser"
	"main/internal/qobuz"
	"main/internal/ui"
	"main/internal/utils"
	"main/utils/lyrics"
	"main/utils/runv14"
	"main/utils/runv3"
	"main/utils/structs"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/fatih/color"
)

type JsonStatus struct {
	Status     string `json:"status"`
	TrackNum   int    `json:"trackNum"`
	TrackName  string `json:"trackName"`
	Percentage int    `json:"percentage"`
	Speed      string `json:"speed"`
	Message    string `json:"message"`
	AlbumID    string `json:"albumId"`
	AlbumName  string `json:"albumName,omitempty"`
}

func printJSON(albumId string, trackNum int, trackName string, albumName string, status string, percentage int, speed string, message string) {
	statusJSON, _ := json.Marshal(JsonStatus{
		AlbumID:    albumId,
		TrackNum:   trackNum,
		TrackName:  trackName,
		AlbumName:  albumName,
		Status:     status,
		Percentage: percentage,
		Speed:      speed,
		Message:    message,
	})
	fmt.Println(string(statusJSON))
}

func checkAndReEncodeTrack(trackPath string, updateStatus func(status string, sColor func(a ...interface{}) string), jsonOutput bool, albumId string, trackNum int, trackName string) (bool, error) {
	if !jsonOutput {
		updateStatus("正在检测...", color.New(color.FgCyan).SprintFunc())
	}
	checkArgs := strings.Fields(core.Config.FfmpegCheckArgs)
	cmdCheckArgs := append([]string{"-i", trackPath}, checkArgs...)
	checkCmd := exec.Command("ffmpeg", cmdCheckArgs...)

	var stderr bytes.Buffer
	checkCmd.Stderr = &stderr
	err := checkCmd.Run()

	if err == nil && stderr.Len() == 0 {
		return false, nil
	}

	if jsonOutput {
		printJSON(albumId, trackNum, trackName, "", "fix", 0, "", "文件损坏, 正在重新编码...")
	} else {
		updateStatus("文件损坏, 正在重新编码...", color.New(color.FgRed).SprintFunc())
	}

	tempTrackPath := trackPath + ".fixed.m4a"
	defer os.Remove(tempTrackPath)

	encodeArgs := strings.Fields(core.Config.FfmpegEncodeArgs)
	cmdEncodeArgs := append([]string{"-i", trackPath}, encodeArgs...)
	cmdEncodeArgs = append(cmdEncodeArgs, tempTrackPath)

	encodeCmd := exec.Command("ffmpeg", cmdEncodeArgs...)
	var encodeStderr bytes.Buffer
	encodeCmd.Stderr = &encodeStderr
	err = encodeCmd.Run()

	if err != nil {
		return true, fmt.Errorf("重新编码失败: %v, FFMPEG输出: %s", err, encodeStderr.String())
	}

	if err := os.Remove(trackPath); err != nil {
		return true, fmt.Errorf("删除损坏的原文件失败: %w", err)
	}
	if err := os.Rename(tempTrackPath, trackPath); err != nil {
		return true, fmt.Errorf("替换为修复文件失败: %w", err)
	}

	return true, nil
}

func downloadTrackWithFallback(track structs.TrackData, meta *structs.AutoGenerated, albumId, storefront, baseSaveFolder, Codec, covPath string, workingAccounts []structs.Account, initialAccountIndex int, updateStatus func(status string, sColor func(a ...interface{}) string), progressChan chan runv14.ProgressUpdate, jsonOutput bool, trackNum int) (string, error) {
	maxRetries := 3
	var lastError error

	for i := 0; i < len(workingAccounts); i++ {
		accountIndex := (initialAccountIndex + i) % len(workingAccounts)
		account := &workingAccounts[accountIndex]

		if !jsonOutput {
			updateStatus(fmt.Sprintf("%s 账号下载中", strings.ToUpper(account.Storefront)), nil)
		}

		for attempt := 0; attempt <= maxRetries; attempt++ {
			trackPath, err := downloadTrackSilently(track, meta, albumId, storefront, baseSaveFolder, Codec, covPath, account, progressChan, jsonOutput)
			if err == nil {
				return trackPath, nil
			}
			lastError = err
			if attempt < maxRetries {
				time.Sleep(2 * time.Second)
			}
		}
		warningMsg := fmt.Sprintf("账户 %s 失败, 尝试下一个...", account.Name)
		if jsonOutput {
			printJSON(albumId, trackNum, track.Attributes.Name, "", "error", 0, "", warningMsg)
		} else {
			updateStatus(warningMsg, color.New(color.FgRed).SprintFunc())
		}
		time.Sleep(1 * time.Second)
	}

	return "", fmt.Errorf("所有可用账户均尝试失败: %w", lastError)
}

func downloadTrackSilently(track structs.TrackData, meta *structs.AutoGenerated, albumId, storefront, baseSaveFolder, Codec, covPath string, account *structs.Account, progressChan chan runv14.ProgressUpdate, jsonOutput bool) (string, error) {
	if track.Type == "music-videos" {
		if !core.Config.DownloadVideos {
			core.OkDict[albumId] = append(core.OkDict[albumId], -1)
			return "", nil
		}

		if len(account.MediaUserToken) <= 50 {
			return "", errors.New("media-user-token is not set, skip MV dl")
		}
		if _, err := exec.LookPath("mp4decrypt"); err != nil {
			return "", errors.New("mp4decrypt is not found, skip MV dl")
		}

		var singerFoldername, albumFoldername string
		if core.Config.ArtistFolderFormat != "" {
			if strings.Contains(albumId, "pl.") {
				singerFoldername = strings.NewReplacer(
					"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
				).Replace(core.Config.ArtistFolderFormat)
			} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
				singerFoldername = strings.NewReplacer(
					"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
				).Replace(core.Config.ArtistFolderFormat)
			} else {
				singerFoldername = strings.NewReplacer(
					"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistId}", "",
				).Replace(core.Config.ArtistFolderFormat)
			}
		}

		Quality := "Video"
		MVCodec := "H.264"
		Tag_string := ""

		if strings.Contains(albumId, "pl.") {
			albumFoldername = strings.NewReplacer(
				"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
				"{PlaylistId}", albumId, "{Quality}", Quality, "{Codec}", MVCodec, "{Tag}", Tag_string,
			).Replace(core.Config.PlaylistFolderFormat)
		} else {
			albumFoldername = strings.NewReplacer(
				"{ReleaseDate}", meta.Data[0].Attributes.ReleaseDate, "{ReleaseYear}", meta.Data[0].Attributes.ReleaseDate[:4],
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName), "{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
				"{UPC}", meta.Data[0].Attributes.Upc, "{RecordLabel}", meta.Data[0].Attributes.RecordLabel,
				"{Copyright}", meta.Data[0].Attributes.Copyright, "{AlbumId}", albumId,
				"{Quality}", Quality, "{Codec}", MVCodec, "{Tag}", Tag_string,
			).Replace(core.Config.AlbumFolderFormat)
		}

		sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
		sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")
		mvOutPath, err := MvDownloader(track.ID, baseSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, storefront, meta, account, progressChan, jsonOutput)
		if err != nil {
			return "", fmt.Errorf("failed to dl MV: %w", err)
		}
		return mvOutPath, nil
	}

	manifest, err := api.GetInfoFromAdam(track.ID, account, storefront)
	if err != nil {
		return "", fmt.Errorf("failed to get manifest with account %s: %w", account.Name, err)
	}

	needDlAacLc := false
	if core.Dl_aac && *core.Aac_type == "aac-lc" {
		needDlAacLc = true
	}
	if manifest.Attributes.ExtendedAssetUrls.EnhancedHls == "" {
		if core.Dl_atmos {
			return "", errors.New("atmos unavailable")
		}
		needDlAacLc = true
	}
	needCheck := false

	if core.Config.GetM3u8Mode == "all" {
		needCheck = true
	} else if core.Config.GetM3u8Mode == "hires" && utils.Contains(track.Attributes.AudioTraits, "hi-res-lossless") {
		needCheck = true
	}
	var EnhancedHls_m3u8 string
	if needCheck && !needDlAacLc {
		EnhancedHls_m3u8, _ = parser.CheckM3u8(track.ID, "song", account)
		if strings.HasSuffix(EnhancedHls_m3u8, ".m3u8") {
			manifest.Attributes.ExtendedAssetUrls.EnhancedHls = EnhancedHls_m3u8
		}
	}
	var Quality string
	if strings.Contains(core.Config.SongFileFormat, "Quality") {
		if core.Dl_atmos {
			Quality = fmt.Sprintf("%dkbps", *core.Atmos_max-2000)
		} else if needDlAacLc {
			Quality = "256kbps"
		} else {
			_, Quality, _, err = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, true)
			if err != nil {
				Quality = ""
			}
		}
	}
	stringsToJoin := []string{}
	if track.Attributes.IsAppleDigitalMaster {
		if core.Config.AppleMasterChoice != "" {
			stringsToJoin = append(stringsToJoin, core.Config.AppleMasterChoice)
		}
	}
	if track.Attributes.ContentRating == "explicit" {
		if core.Config.ExplicitChoice != "" {
			stringsToJoin = append(stringsToJoin, core.Config.ExplicitChoice)
		}
	}
	if track.Attributes.ContentRating == "clean" {
		if core.Config.CleanChoice != "" {
			stringsToJoin = append(stringsToJoin, core.Config.CleanChoice)
		}
	}
	Tag_string := strings.Join(stringsToJoin, " ")

	trackNum := -1
	for i, t := range meta.Data[0].Relationships.Tracks.Data {
		if t.ID == track.ID {
			trackNum = i + 1
			break
		}
	}
	if trackNum == -1 {
		return "", errors.New("track not found in metadata")
	}

	var singerFoldername, albumFoldername string
	if core.Config.ArtistFolderFormat != "" {
		if strings.Contains(albumId, "pl.") {
			singerFoldername = strings.NewReplacer(
				"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
			).Replace(core.Config.ArtistFolderFormat)
		} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
			).Replace(core.Config.ArtistFolderFormat)
		} else {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", "",
			).Replace(core.Config.ArtistFolderFormat)
		}
	}

	if strings.Contains(albumId, "pl.") {
		albumFoldername = strings.NewReplacer(
			"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{PlaylistId}", albumId, "{Quality}", Quality, "{Codec}", Codec, "{Tag}", Tag_string,
		).Replace(core.Config.PlaylistFolderFormat)
	} else {
		albumFoldername = strings.NewReplacer(
			"{ReleaseDate}", meta.Data[0].Attributes.ReleaseDate, "{ReleaseYear}", meta.Data[0].Attributes.ReleaseDate[:4],
			"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName), "{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{UPC}", meta.Data[0].Attributes.Upc, "{RecordLabel}", meta.Data[0].Attributes.RecordLabel,
			"{Copyright}", meta.Data[0].Attributes.Copyright, "{AlbumId}", albumId,
			"{Quality}", Quality, "{Codec}", Codec, "{Tag}", Tag_string,
		).Replace(core.Config.AlbumFolderFormat)
	}

	songName := strings.NewReplacer(
		"{SongId}", track.ID,
		"{SongNumer}", fmt.Sprintf("%02d", trackNum),
		"{SongName}", core.LimitString(track.Attributes.Name),
		"{DiscNumber}", fmt.Sprintf("%0d", track.Attributes.DiscNumber),
		"{TrackNumber}", fmt.Sprintf("%0d", track.Attributes.TrackNumber),
		"{Quality}", Quality,
		"{Tag}", Tag_string,
		"{Codec}", Codec,
	).Replace(core.Config.SongFileFormat)

	sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
	sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")
	sanitizedSongName := core.ForbiddenNames.ReplaceAllString(songName, "_")
	filenameWithExt := fmt.Sprintf("%s.m4a", sanitizedSongName)

	finalArtistDir, finalAlbumDir, finalFilename := utils.EnsureSafePath(baseSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, filenameWithExt)
	var finalSingerFolder string
	if finalArtistDir != "" {
		finalSingerFolder = filepath.Join(baseSaveFolder, finalArtistDir)
	} else {
		finalSingerFolder = baseSaveFolder
	}
	finalAlbumFolder := filepath.Join(finalSingerFolder, finalAlbumDir)
	os.MkdirAll(finalAlbumFolder, os.ModePerm)
	trackPath := filepath.Join(finalAlbumFolder, finalFilename)

	exists, err := utils.FileExists(trackPath)
	if err != nil {
		return "", errors.New("failed to check if track exists")
	}
	if exists {
		core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
		return trackPath, nil
	}

	if needDlAacLc {
		if len(account.MediaUserToken) <= 50 {
			return "", errors.New("invalid media-user-token")
		}
		_, err := runv3.Run(track.ID, trackPath, core.DeveloperToken, account.MediaUserToken, false)
		if err != nil {
			return "", fmt.Errorf("failed to dl aac-lc: %w", err)
		}
	} else {
		trackM3u8Url, _, _, err := parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, false)
		if err != nil {
			return "", fmt.Errorf("failed to extract info from manifest: %w", err)
		}
		err = runv14.Run(track.ID, trackM3u8Url, trackPath, account, core.Config, progressChan)
		if err != nil {
			return "", fmt.Errorf("failed to run v14 with account %s: %w", account.Name, err)
		}
	}

	tags := []string{
		"tool=",
	}
	var trackCovPath string
	if core.Config.EmbedCover {
		if strings.Contains(albumId, "pl.") && core.Config.DlAlbumcoverForPlaylist {
			_, _, safeCoverFilename := utils.EnsureSafePath(baseSaveFolder, finalArtistDir, finalAlbumDir, track.ID+".jpg")
			trackCovPath, err = metadata.WriteCover(finalAlbumFolder, strings.TrimSuffix(safeCoverFilename, ".jpg"), track.Attributes.Artwork.URL)
			if err == nil {
				tags = append(tags, fmt.Sprintf("cover=%s", trackCovPath))
			}
		} else {
			tags = append(tags, fmt.Sprintf("cover=%s", covPath))
		}
	}
	tagsString := strings.Join(tags, ":")
	cmd := exec.Command("MP4Box", "-quiet", "-itags", tagsString, trackPath)
	_ = cmd.Run()
	if strings.Contains(albumId, "pl.") && core.Config.DlAlbumcoverForPlaylist && trackCovPath != "" {
		_ = os.Remove(trackCovPath)
	}

	core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
	return trackPath, nil
}

func Rip(albumId string, storefront string, urlArg_i string, urlRaw string, jsonOutput bool) error {
	mainAccount, err := core.GetAccountForStorefront(storefront)
	if err != nil {
		return err
	}

	meta, err := api.GetMeta(albumId, mainAccount, storefront)
	if err != nil {
		return err
	}
	var lyricAccount *structs.Account
	for i := range core.Config.Accounts {
		acc := &core.Config.Accounts[i]
		if strings.ToLower(acc.Storefront) == strings.ToLower(storefront) {
			lyricAccount = acc
			break
		}
	}

	if lyricAccount == nil && core.Config.DefaultLyricStorefront != "" {
		for i := range core.Config.Accounts {
			acc := &core.Config.Accounts[i]
			if strings.ToLower(acc.Storefront) == strings.ToLower(core.Config.DefaultLyricStorefront) {
				lyricAccount = acc
				break
			}
		}
	}

	if core.Debug_mode {
		if len(meta.Data[0].Relationships.Tracks.Data) > 0 {
			firstTrack := meta.Data[0].Relationships.Tracks.Data[0]
			manifest, err := api.GetInfoFromAdam(firstTrack.ID, mainAccount, storefront)
			if err == nil && manifest.Attributes.ExtendedAssetUrls.EnhancedHls != "" {
				_, _, _, _ = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, true)
			}
		}
		return nil
	}

	var Codec string
	if core.Dl_atmos {
		Codec = "ATMOS"
	} else if core.Dl_aac {
		Codec = "AAC"
	} else {
		Codec = "ALAC"
	}

	var baseSaveFolder string
	if core.Dl_atmos {
		baseSaveFolder = core.Config.AtmosSaveFolder
	} else {
		baseSaveFolder = core.Config.AlacSaveFolder
	}

	var singerFoldername, albumFoldername string
	if core.Config.ArtistFolderFormat != "" {
		if strings.Contains(albumId, "pl.") {
			singerFoldername = strings.NewReplacer(
				"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
			).Replace(core.Config.ArtistFolderFormat)
		} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
			).Replace(core.Config.ArtistFolderFormat)
		} else {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", "",
			).Replace(core.Config.ArtistFolderFormat)
		}
	}

	var Quality string
	Tag_string := ""

	if strings.Contains(albumId, "pl.") {
		albumFoldername = strings.NewReplacer(
			"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{PlaylistId}", albumId, "{Quality}", Quality, "{Codec}", Codec, "{Tag}", Tag_string,
		).Replace(core.Config.PlaylistFolderFormat)
	} else {
		albumFoldername = strings.NewReplacer(
			"{ReleaseDate}", meta.Data[0].Attributes.ReleaseDate, "{ReleaseYear}", meta.Data[0].Attributes.ReleaseDate[:4],
			"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName), "{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{UPC}", meta.Data[0].Attributes.Upc, "{RecordLabel}", meta.Data[0].Attributes.RecordLabel,
			"{Copyright}", meta.Data[0].Attributes.Copyright, "{AlbumId}", albumId,
			"{Quality}", Quality, "{Codec}", Codec, "{Tag}", Tag_string,
		).Replace(core.Config.AlbumFolderFormat)
	}

	sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
	sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")

	var longestFilename string
	for i := range meta.Data[0].Relationships.Tracks.Data {
		if len(meta.Data[0].Relationships.Tracks.Data[i].Attributes.Name) > len(longestFilename) {
			longestFilename = meta.Data[0].Relationships.Tracks.Data[i].Attributes.Name
		}
	}
	longestFilename = strings.NewReplacer(
		"{SongName}", longestFilename,
		"{SongNumer}", "99",
		"{Quality}", "24B-192.0kHz",
		"{Tag}", core.Config.AppleMasterChoice+" "+core.Config.ExplicitChoice,
		"{Codec}", "ATMOS",
	).Replace(core.Config.SongFileFormat) + ".m4a"

	finalArtistDir, finalAlbumDir, _ := utils.EnsureSafePath(baseSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, longestFilename)

	var finalSingerFolder string
	if finalArtistDir != "" {
		finalSingerFolder = filepath.Join(baseSaveFolder, finalArtistDir)
	} else {
		finalSingerFolder = baseSaveFolder
	}
	finalAlbumFolder := filepath.Join(finalSingerFolder, finalAlbumDir)
	os.MkdirAll(finalAlbumFolder, os.ModePerm)

	if !jsonOutput {
		fmt.Printf("歌手: %s\n", meta.Data[0].Attributes.ArtistName)
		fmt.Printf("专辑: %s\n", meta.Data[0].Attributes.Name)
	} else {
		printJSON(albumId, 0, "", meta.Data[0].Attributes.Name, "log", 0, "", "专辑信息已获取")
	}

	if core.Config.SaveArtistCover && !(strings.Contains(albumId, "pl.")) {
		if len(meta.Data[0].Relationships.Artists.Data) > 0 {
			_, err = metadata.WriteCover(finalSingerFolder, "folder", meta.Data[0].Relationships.Artists.Data[0].Attributes.Artwork.Url)
			if err != nil {
			}
		}
	}
	covPath, err := metadata.WriteCover(finalAlbumFolder, "cover", meta.Data[0].Attributes.Artwork.URL)
	if err != nil {
	}

	var qobuzDesc string
	var pdfUrls []qobuz.PDFExtra
	if !strings.Contains(albumId, "pl.") {
		qobuzDesc, pdfUrls, err = qobuz.GetQobuzExtras(meta.Data[0].Attributes.ArtistName, meta.Data[0].Attributes.Name)
		if err != nil {
			if jsonOutput {
				printJSON(albumId, 0, "", meta.Data[0].Attributes.Name, "log", 0, "", fmt.Sprintf("Qobuz元数据获取失败: %v", err))
			} else {
				fmt.Printf("Qobuz元数据获取失败: %v\n", err)
			}
		}
	}

	if pdfUrls != nil && len(pdfUrls) > 0 {
		if jsonOutput {
			printJSON(albumId, 0, "", meta.Data[0].Attributes.Name, "log", 0, "", fmt.Sprintf("正在下载 %d 个 Qobuz PDF...", len(pdfUrls)))
		} else {
			fmt.Printf("正在下载 %d 个 Qobuz PDF...\n", len(pdfUrls))
		}
		for _, pdf := range pdfUrls {
			const maxAttempts = 3
			var err error
			for attempt := 1; attempt <= maxAttempts; attempt++ {
				err = qobuz.DownloadPDF(pdf, finalAlbumFolder)
				if err == nil {
					break
				}

				if attempt < maxAttempts {
					if jsonOutput {
						printJSON(albumId, 0, "", meta.Data[0].Attributes.Name, "log", 0, "", fmt.Sprintf("PDF下载失败 (尝试 %d/%d), 2秒后重试: %s -> %v", attempt, maxAttempts, pdf.URL, err))
					} else {
						fmt.Printf("PDF下载失败 (尝试 %d/%d), 2秒后重试: %s -> %v\n", attempt, maxAttempts, pdf.URL, err)
					}
					time.Sleep(2 * time.Second)
				}
			}

			if err != nil {
				if jsonOutput {
					printJSON(albumId, 0, "", meta.Data[0].Attributes.Name, "log", 0, "", fmt.Sprintf("PDF下载最终失败: %s -> %v", pdf.URL, err))
				} else {
					fmt.Printf("PDF下载最终失败: %s -> %v\n", pdf.URL, err)
				}
			}
		}
	}

	if core.Config.SaveAnimatedArtwork && meta.Data[0].Attributes.EditorialVideo.MotionDetailSquare.Video != "" {
		motionvideoUrlSquare, err := parser.ExtractVideo(meta.Data[0].Attributes.EditorialVideo.MotionDetailSquare.Video)
		if err == nil {
			exists, _ := utils.FileExists(filepath.Join(finalAlbumFolder, "square_animated_artwork.mp4"))
			if !exists {
				cmd := exec.Command("ffmpeg", "-loglevel", "quiet", "-y", "-i", motionvideoUrlSquare, "-c", "copy", filepath.Join(finalAlbumFolder, "square_animated_artwork.mp4"))
				_ = cmd.Run()
			}
		}

		if core.Config.EmbyAnimatedArtwork {
			cmd3 := exec.Command("ffmpeg", "-loglevel", "quiet", "-y", "-i", filepath.Join(finalAlbumFolder, "square_animated_artwork.mp4"), "-vf", "scale=440:-1", "-r", "24", "-f", "gif", filepath.Join(finalAlbumFolder, "folder.jpg"))
			_ = cmd3.Run()
		}

		motionvideoUrlTall, err := parser.ExtractVideo(meta.Data[0].Attributes.EditorialVideo.MotionDetailTall.Video)
		if err == nil {
			exists, _ := utils.FileExists(filepath.Join(finalAlbumFolder, "tall_animated_artwork.mp4"))
			if !exists {
				cmd := exec.Command("ffmpeg", "-loglevel", "quiet", "-y", "-i", motionvideoUrlTall, "-c", "copy", filepath.Join(finalAlbumFolder, "tall_animated_artwork.mp4"))
				_ = cmd.Run()
			}
		}
	}

	var selected []int
	if jsonOutput {
		trackTotal := len(meta.Data[0].Relationships.Tracks.Data)
		arr := make([]int, trackTotal)
		for i := 0; i < trackTotal; i++ {
			arr[i] = i + 1
		}

		if core.Dl_song {
			found := false
			for i, track := range meta.Data[0].Relationships.Tracks.Data {
				if urlArg_i == track.ID {
					selected = append(selected, i+1)
					found = true
					break
				}
			}
			if !found {
				printJSON(albumId, 0, meta.Data[0].Attributes.Name, "", "error", 0, "", "指定的单曲ID未在专辑中找到")
				return errors.New("指定的单曲ID未在专辑中找到")
			}
		} else {
			selected = arr
		}

	} else {
		selected = ui.SelectTracks(meta, storefront, urlArg_i)
	}
	if selected == nil {
		if !jsonOutput {
			fmt.Println("未选择任何曲目")
		}
		return nil
	}

	if !jsonOutput {
		fmt.Println("正在进行版权预检，请稍候...")
	}

	var workingAccounts []structs.Account
	if len(meta.Data[0].Relationships.Tracks.Data) > 0 {
		firstTrackId := meta.Data[0].Relationships.Tracks.Data[0].ID
		for _, acc := range core.Config.Accounts {
			if !core.Config.GlobalDecryption && strings.ToLower(acc.Storefront) != strings.ToLower(storefront) {
				continue
			}
			_, err := api.GetInfoFromAdam(firstTrackId, &acc, acc.Storefront)
			if err == nil {
				workingAccounts = append(workingAccounts, acc)
			} else {
				if !jsonOutput {
					fmt.Printf("账户 [%s] 无法访问此专辑 (可能无版权)，本次任务将跳过该账户\n", acc.Name)
				}
			}
		}
	} else {
		return errors.New("专辑中没有曲目")
	}

	if len(workingAccounts) == 0 {
		return errors.New("所有账户均无法访问此专辑，任务中止")
	}

	albumQualityType := "AAC"
	albumQualityString := "AAC"
	isHires := false
	isLossless := false

	for _, trackIndex := range selected {
		track := meta.Data[0].Relationships.Tracks.Data[trackIndex-1]
		if utils.Contains(track.Attributes.AudioTraits, "hi-res-lossless") {
			isHires = true
			break
		}
		if utils.Contains(track.Attributes.AudioTraits, "lossless") {
			isLossless = true
		}
	}

	if isHires {
		albumQualityType = "Hi-Res Lossless"
		albumQualityString = "Hi-Res Lossless"
	} else if isLossless {
		albumQualityType = "Lossless"
		albumQualityString = "Lossless"
	}

	var numThreads int
	switch albumQualityType {
	case "Hi-Res Lossless":
		numThreads = core.Config.HiresDownloadThreads
	case "Lossless":
		numThreads = core.Config.LosslessDownloadThreads
	default:
		numThreads = core.Config.AacDownloadThreads
	}

	if numThreads < 1 {
		numThreads = 1
	}

	regionSet := make(map[string]bool)
	for _, acc := range workingAccounts {
		if acc.Storefront != "" {
			regionSet[strings.ToUpper(acc.Storefront)] = true
		}
	}
	var regionNames []string
	for r := range regionSet {
		regionNames = append(regionNames, r)
	}
	sort.Strings(regionNames)
	regionsStr := strings.Join(regionNames, " / ")

	if !jsonOutput {
		yellow := color.New(color.FgYellow).SprintFunc()
		green := color.New(color.FgGreen).SprintFunc()
		fmt.Printf("%s %s | %s | %s | %s\n",
			green("音源:"),
			green(albumQualityString),
			green(fmt.Sprintf("%d 个线程并行下载", numThreads)),
			yellow(regionsStr),
			green(fmt.Sprintf("%d 个端口并行解密", len(workingAccounts))),
		)
		fmt.Println(strings.Repeat("-", 50))
	}

	core.RipLock.Lock()
	defer core.RipLock.Unlock()

	var wg sync.WaitGroup

	var pui *ui.ProgressUI
	if !jsonOutput {
		pui = ui.NewProgressUI(nil)
	}

	semaphore := make(chan struct{}, numThreads)
	var dispatchCounter uint64

	for _, trackNum := range selected {
		wg.Add(1)
		go func(trackIndexInMeta int) {
			semaphore <- struct{}{}

			currentDispatch := atomic.AddUint64(&dispatchCounter, 1) - 1
			statusIndex := int(currentDispatch)

			semaphoreReleased := false

			releaseSem := func() {
				if !semaphoreReleased {
					<-semaphore
					semaphoreReleased = true
				}
			}

			defer func() {
				releaseSem()
				if r := recover(); r != nil {
					fmt.Printf("\nFATAL: Goroutine for track %d panicked: %v\n", trackIndexInMeta, r)
				}
				wg.Done()
			}()

			trackData := meta.Data[0].Relationships.Tracks.Data[trackIndexInMeta-1]

			updateStatus := func(newStatus string, _ func(a ...interface{}) string) {
				if !jsonOutput && pui != nil {
					pui.UpdateStatus(trackIndexInMeta, newStatus)
				}
			}

			if !jsonOutput && pui != nil {
				manifest, err := api.GetInfoFromAdam(trackData.ID, mainAccount, storefront)
				quality := "N/A"
				if err == nil && manifest.Attributes.ExtendedAssetUrls.EnhancedHls != "" {
					_, _, quality, err = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, false)
					if err != nil {
						quality = "获取失败"
					}
				} else {
					quality = "AAC 256kbps"
				}

				qualityStr := fmt.Sprintf("(%s)", quality)
				totalTracks := len(meta.Data[0].Relationships.Tracks.Data)

				pui.AddTrack(trackIndexInMeta, totalTracks, trackData.Attributes.Name, qualityStr)
			}

			core.SharedLock.Lock()
			isDone := utils.IsInArray(core.OkDict[albumId], trackIndexInMeta)
			core.SharedLock.Unlock()

			if isDone {
				if jsonOutput {
					printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "exists", 100, "", "已存在")
				} else if pui != nil {
					pui.SetDone(trackIndexInMeta, "已存在")
				}
				core.SharedLock.Lock()
				core.Counter.Total++
				core.Counter.Success++
				core.SharedLock.Unlock()
				return
			}

			if jsonOutput {
				printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "start", 0, "", "等待下载...")
			}

			const PostDownloadMaxRetries = 3

			for attempt := 1; attempt <= PostDownloadMaxRetries; attempt++ {
				if semaphoreReleased {
					semaphore <- struct{}{}
					semaphoreReleased = false
				}

				if attempt > 1 {
					if jsonOutput {
						printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "progress", 0, "", fmt.Sprintf("第 %d/%d 次重试...", attempt, PostDownloadMaxRetries))
					} else {
						updateStatus(fmt.Sprintf("第 %d/%d 次重试...", attempt, PostDownloadMaxRetries), nil)
					}
					time.Sleep(2 * time.Second)
				}

				progressChan := make(chan runv14.ProgressUpdate, 10)
				go func() {
					accountName := ""
					if len(workingAccounts) > 0 {
						account := &workingAccounts[statusIndex%len(workingAccounts)]
						accountName = strings.ToUpper(account.Storefront)
					}

					if !jsonOutput && pui != nil {
						pui.HandleProgress(trackIndexInMeta, progressChan, accountName)
					} else {
						for p := range progressChan {
							status := "progress"
							if p.Stage == "decrypt" {
								status = "decrypt"
							}
							printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, status, p.Percentage, utils.FormatSpeed(p.SpeedBPS), "")
						}
					}
				}()

				trackPath, err := downloadTrackWithFallback(trackData, meta, albumId, storefront, baseSaveFolder, Codec, covPath, workingAccounts, statusIndex, updateStatus, progressChan, jsonOutput, trackIndexInMeta)
				close(progressChan)

				if err != nil {
					core.SharedLock.Lock()
					core.Counter.Total++
					errMsg := fmt.Sprintln("下载失败:", err)
					if jsonOutput {
						printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "error", 0, "", errMsg)
					} else if pui != nil {
						pui.Abort(trackIndexInMeta, strings.TrimSpace(errMsg))
					}
					core.Counter.Error++
					core.SharedLock.Unlock()
					return
				}

				releaseSem()

				var postDownloadError error
				wasFixed := false
				if core.Config.FfmpegFix && trackData.Type != "music-videos" {
					isAAC := core.Dl_aac && *core.Aac_type == "aac-lc"
					if !isAAC {
						var fixErr error
						wasFixed, fixErr = checkAndReEncodeTrack(trackPath, updateStatus, jsonOutput, albumId, trackIndexInMeta, trackData.Attributes.Name)
						if fixErr != nil {
							postDownloadError = fmt.Errorf("修复失败: %w", fixErr)
						}
					}
				}
				if postDownloadError == nil {
					var finalLrc string
					if lyricAccount != nil && (core.Config.EmbedLrc || core.Config.SaveLrcFile) && trackData.Type != "music-videos" {
						lrcStr, lrcErr := lyrics.Get(storefront, trackData.ID, core.Config.LrcType, core.Config.Language, core.Config.LrcFormat, core.DeveloperToken, lyricAccount.MediaUserToken)
						if lrcErr == nil {
							if core.Config.SaveLrcFile {
								lrcFilename := fmt.Sprintf("%s.lrc", strings.TrimSuffix(filepath.Base(trackPath), filepath.Ext(filepath.Base(trackPath))))
								_ = metadata.WriteLyrics(filepath.Dir(trackPath), lrcFilename, lrcStr)
							}
							if core.Config.EmbedLrc {
								finalLrc = lrcStr
							}
						}
					}

					tagErr := metadata.WriteMP4Tags(trackPath, finalLrc, qobuzDesc, meta, trackIndexInMeta, len(meta.Data[0].Relationships.Tracks.Data))
					if tagErr != nil {
						postDownloadError = fmt.Errorf("标签写入失败: %w", tagErr)
					}
				}

				if postDownloadError != nil {
					if jsonOutput {
						printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "error", 0, "", postDownloadError.Error())
					} else {
						updateStatus(postDownloadError.Error(), nil)
					}

					os.Remove(trackPath)

					if attempt < PostDownloadMaxRetries {
						continue
					} else {
						errMsg := fmt.Sprintln("所有重试均失败:", postDownloadError)
						if jsonOutput {
							printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "error", 0, "", errMsg)
						} else if pui != nil {
							pui.Abort(trackIndexInMeta, strings.TrimSpace(errMsg))
						}

						core.SharedLock.Lock()
						core.Counter.Total++
						core.Counter.Error++
						core.SharedLock.Unlock()
						return
					}
				}
				core.SharedLock.Lock()
				core.Counter.Total++
				core.Counter.Success++
				statusMsg := "下载完成"
				if wasFixed {
					statusMsg = "重编码完成"
				}
				if jsonOutput {
					printJSON(albumId, trackIndexInMeta, trackData.Attributes.Name, meta.Data[0].Attributes.Name, "complete", 100, "", statusMsg)
				} else if pui != nil {
					pui.SetDone(trackIndexInMeta, statusMsg)
				}
				core.SharedLock.Unlock()
				return
			}
		}(trackNum)
	}

	wg.Wait()
	if !jsonOutput && pui != nil {
		pui.Wait()
		fmt.Println(strings.Repeat("-", 50))
	}
	return nil
}

func MvDownloader(adamID string, baseSaveDir, artistDir, albumDir string, storefront string, meta *structs.AutoGenerated, account *structs.Account, progressChan chan runv14.ProgressUpdate, jsonOutput bool) (string, error) {
	MVInfo, err := api.GetMVInfoFromAdam(adamID, account, storefront)
	if err != nil {
		return "", err
	}

	var trackTotal int
	var trackNum int = 1
	var index int
	if meta != nil {
		trackTotal = len(meta.Data[0].Relationships.Tracks.Data)
		for i, track := range meta.Data[0].Relationships.Tracks.Data {
			if adamID == track.ID {
				index = i
				trackNum = i + 1
			}
		}
		if trackNum == 0 {
			trackNum = 1
		}
	}

	var mvSaveName string
	if meta != nil && trackNum > 0 && trackNum <= len(meta.Data[0].Relationships.Tracks.Data) {
		mvSaveName = fmt.Sprintf("%02d. %s", trackNum, MVInfo.Data[0].Attributes.Name)
	} else {
		mvSaveName = MVInfo.Data[0].Attributes.Name
		trackNum = 1
	}

	sanitizedMvSaveName := core.ForbiddenNames.ReplaceAllString(mvSaveName, "_")
	filenameWithExt := fmt.Sprintf("%s.mp4", sanitizedMvSaveName)

	finalArtistDir, finalAlbumDir, finalFilename := utils.EnsureSafePath(baseSaveDir, artistDir, albumDir, filenameWithExt)

	var finalSingerFolder string
	if finalArtistDir != "" {
		finalSingerFolder = filepath.Join(baseSaveDir, finalArtistDir)
	} else {
		finalSingerFolder = baseSaveDir
	}
	finalAlbumFolder := filepath.Join(finalSingerFolder, finalAlbumDir)
	mvOutPath := filepath.Join(finalAlbumFolder, finalFilename)
	os.MkdirAll(finalAlbumFolder, os.ModePerm)
	exists, _ := utils.FileExists(mvOutPath)
	if exists {
		return mvOutPath, nil
	}

	mvm3u8url, _, err := runv3.GetWebplayback(adamID, core.DeveloperToken, account.MediaUserToken, true)
	if err != nil {
		return "", fmt.Errorf("获取MV播放列表失败: %w", err)
	}
	if mvm3u8url == "" {
		return "", errors.New("media-user-token may be wrong or expired")
	}

	vidPath := filepath.Join(finalAlbumFolder, fmt.Sprintf("%s_vid.mp4", adamID))
	audPath := filepath.Join(finalAlbumFolder, fmt.Sprintf("%s_aud.mp4", adamID))

	videom3u8url, err := parser.ExtractVideo(mvm3u8url)
	if err != nil {
		return "", fmt.Errorf("提取视频流URL失败: %w", err)
	}
	videokeyAndUrls, err := runv3.Run(adamID, videom3u8url, core.DeveloperToken, account.MediaUserToken, true)
	if err != nil {
		return "", fmt.Errorf("获取视频密钥和URL失败: %w", err)
	}

	if jsonOutput {
		printJSON(adamID, trackNum, MVInfo.Data[0].Attributes.Name, MVInfo.Data[0].Attributes.Name, "progress", 10, "", "正在下载视频...")
	}
	if progressChan != nil {
		progressChan <- runv14.ProgressUpdate{Percentage: 10, SpeedBPS: 0, Stage: "download"}
	}
	err = runv3.ExtMvData(videokeyAndUrls, vidPath)
	if err != nil {
		return "", fmt.Errorf("下载或解密视频数据失败: %w", err)
	}

	audiom3u8url, err := parser.ExtractMvAudio(mvm3u8url)
	if err != nil {
		return "", fmt.Errorf("提取音频流URL失败: %w", err)
	}
	audiokeyAndUrls, err := runv3.Run(adamID, audiom3u8url, core.DeveloperToken, account.MediaUserToken, true)
	if err != nil {
		return "", fmt.Errorf("获取音频密钥和URL失败: %w", err)
	}

	if jsonOutput {
		printJSON(adamID, trackNum, MVInfo.Data[0].Attributes.Name, MVInfo.Data[0].Attributes.Name, "progress", 50, "", "正在下载音频...")
	}
	if progressChan != nil {
		progressChan <- runv14.ProgressUpdate{Percentage: 50, SpeedBPS: 0, Stage: "download"}
	}
	err = runv3.ExtMvData(audiokeyAndUrls, audPath)
	if err != nil {
		return "", fmt.Errorf("下载或解密视频数据失败: %w", err)
	}

	tags := []string{
		"tool=",
		fmt.Sprintf("artist=%s", MVInfo.Data[0].Attributes.ArtistName),
		fmt.Sprintf("title=%s", MVInfo.Data[0].Attributes.Name),
		fmt.Sprintf("genre=%s", MVInfo.Data[0].Attributes.GenreNames[0]),
		fmt.Sprintf("created=%s", MVInfo.Data[0].Attributes.ReleaseDate),
		fmt.Sprintf("ISRC=%s", MVInfo.Data[0].Attributes.Isrc),
	}

	if MVInfo.Data[0].Attributes.ContentRating == "explicit" {
		tags = append(tags, "rating=1")
	} else if MVInfo.Data[0].Attributes.ContentRating == "clean" {
		tags = append(tags, "rating=2")
	} else {
		tags = append(tags, "rating=0")
	}

	if meta != nil {
		if meta.Data[0].Type == "playlists" && !core.Config.UseSongInfoForPlaylist {
			tags = append(tags, "disk=1/1", fmt.Sprintf("album=%s", meta.Data[0].Attributes.Name), fmt.Sprintf("track=%d", trackNum), fmt.Sprintf("tracknum=%d/%d", trackNum, trackTotal), fmt.Sprintf("album_artist=%s", meta.Data[0].Attributes.ArtistName), fmt.Sprintf("performer=%s", meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName), fmt.Sprintf("copyright=%s", meta.Data[0].Attributes.Copyright), fmt.Sprintf("UPC=%s", meta.Data[0].Attributes.Upc))
		} else {
			tags = append(tags, fmt.Sprintf("album=%s", meta.Data[0].Relationships.Tracks.Data[index].Attributes.AlbumName), fmt.Sprintf("disk=%d/%d", meta.Data[0].Relationships.Tracks.Data[index].Attributes.DiscNumber, meta.Data[0].Relationships.Tracks.Data[trackTotal-1].Attributes.DiscNumber), fmt.Sprintf("track=%d", meta.Data[0].Relationships.Tracks.Data[index].Attributes.TrackNumber), fmt.Sprintf("tracknum=%d/%d", meta.Data[0].Relationships.Tracks.Data[index].Attributes.TrackNumber, meta.Data[0].Attributes.TrackCount), fmt.Sprintf("album_artist=%s", meta.Data[0].Attributes.ArtistName), fmt.Sprintf("performer=%s", meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName), fmt.Sprintf("copyright=%s", meta.Data[0].Attributes.Copyright), fmt.Sprintf("UPC=%s", meta.Data[0].Attributes.Upc))
		}
	} else {
		tags = append(tags, fmt.Sprintf("album=%s", MVInfo.Data[0].Attributes.AlbumName), fmt.Sprintf("disk=%d", MVInfo.Data[0].Attributes.DiscNumber), fmt.Sprintf("track=%d", MVInfo.Data[0].Attributes.TrackNumber), fmt.Sprintf("tracknum=%d", MVInfo.Data[0].Attributes.TrackNumber), fmt.Sprintf("performer=%s", MVInfo.Data[0].Attributes.ArtistName))
	}

	var covPath string
	if true {
		thumbURL := MVInfo.Data[0].Attributes.Artwork.URL
		baseThumbName := core.ForbiddenNames.ReplaceAllString(mvSaveName, "_") + "_thumbnail"
		covPath, err = metadata.WriteCover(finalAlbumFolder, baseThumbName, thumbURL)
		if err == nil {
			tags = append(tags, fmt.Sprintf("cover=%s", covPath))
		}
	}

	tagsString := strings.Join(tags, ":")

	if jsonOutput {
		printJSON(adamID, trackNum, MVInfo.Data[0].Attributes.Name, MVInfo.Data[0].Attributes.Name, "decrypt", 90, "", "正在合成...")
	}
	if progressChan != nil {
		progressChan <- runv14.ProgressUpdate{Percentage: 90, SpeedBPS: 0, Stage: "decrypt"}
	}
	muxCmd := exec.Command("MP4Box", "-itags", tagsString, "-quiet", "-add", vidPath, "-add", audPath, "-keep-utc", "-new", mvOutPath)
	if err := muxCmd.Run(); err != nil {
		return "", err
	}
	defer os.Remove(vidPath)
	defer os.Remove(audPath)
	if covPath != "" {
		defer os.Remove(covPath)
	}
	return mvOutPath, nil
}
