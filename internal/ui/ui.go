package ui

import (
	"bufio"
	"errors"
	"fmt"
	"main/utils/structs"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"main/internal/core"

	"github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
)

// UI暂停/恢复控制通道
var (
	suspendChan = make(chan struct{}, 1)
	resumeChan  = make(chan struct{}, 1)
	isSuspended = false
)

// Suspend 暂停UI更新（用于需要直接输出或交互的场景）
func Suspend() {
	select {
	case suspendChan <- struct{}{}:
		isSuspended = true
	default:
		// 已经在暂停状态，忽略
	}
}

// Resume 恢复UI更新
func Resume() {
	if isSuspended {
		select {
		case resumeChan <- struct{}{}:
			isSuspended = false
		default:
			// 已经在运行状态，忽略
		}
	}
}

func RenderUI(done <-chan struct{}) {
	ticker := time.NewTicker(300 * time.Millisecond)
	defer ticker.Stop()
	
	// 首次更新标志：延迟初始化，避免预先打印换行符导致光标位置错误
	firstUpdate := true

	for {
		select {
		case <-done:
			return
		case <-suspendChan:
			// UI暂停，等待恢复信号
			<-resumeChan
		case <-ticker.C:
			PrintUI(firstUpdate)
			firstUpdate = false
		}
	}
}

func PrintUI(isFirstUpdate bool) {
	core.UiMutex.Lock()
	defer core.UiMutex.Unlock()

	if len(core.TrackStatuses) == 0 {
		return
	}

	var builder strings.Builder

	// 首次更新时打印占位换行符，后续更新时向上移动光标
	if isFirstUpdate {
		builder.WriteString(strings.Repeat("\n", len(core.TrackStatuses)))
	}
	
	builder.WriteString(fmt.Sprintf("\033[%dA", len(core.TrackStatuses)))

	terminalWidth := 120
	colorRegex := regexp.MustCompile(`\x1b\[[0-9;]*m`)

	for _, ts := range core.TrackStatuses {
		displayName := ts.TrackName
		prefixStr := fmt.Sprintf("Track %d of %d: ", ts.TrackNum, ts.TrackTotal)
		qualityStr := ts.Quality
		statusStrWithColor := ts.StatusColor(ts.Status)

		plainStatusStr := colorRegex.ReplaceAllString(statusStrWithColor, "")
		prefixRunes := len([]rune(prefixStr))
		suffixRunes := len([]rune(qualityStr)) + len([]rune(" - ")) + len([]rune(plainStatusStr))

		availableRunesForName := terminalWidth - prefixRunes - suffixRunes
		if availableRunesForName < 15 {
			availableRunesForName = 15
		}

		displayNameRunes := []rune(displayName)
		if len(displayNameRunes) > availableRunesForName {
			displayName = string(displayNameRunes[:availableRunesForName-3]) + "..."
		}

		builder.WriteString(fmt.Sprintf("\r\033[K%s%s %s - %s\n", prefixStr, displayName, qualityStr, statusStrWithColor))
	}
	fmt.Print(builder.String())
}

func UpdateStatus(index int, status string, sColor func(a ...interface{}) string) {
	core.UiMutex.Lock()
	defer core.UiMutex.Unlock()
	if index < len(core.TrackStatuses) {
		core.TrackStatuses[index].Status = status
		core.TrackStatuses[index].StatusColor = sColor
	}
}

func SelectTracks(meta *structs.AutoGenerated, storefront, urlArg_i string) []int {
	trackTotal := len(meta.Data[0].Relationships.Tracks.Data)
	arr := make([]int, trackTotal)
	for i := 0; i < trackTotal; i++ {
		arr[i] = i + 1
	}
	selected := []int{}

	if core.Dl_song {
		found := false
		for i, track := range meta.Data[0].Relationships.Tracks.Data {
			if urlArg_i == track.ID {
				selected = append(selected, i+1)
				found = true
				break
			}
		}
		if !found {
			fmt.Println(errors.New("指定的单曲ID未在专辑中找到"))
			return nil
		}
	} else if !core.Dl_select {
		selected = arr
	} else {
		var data [][]string
		for trackNum, track := range meta.Data[0].Relationships.Tracks.Data {
			trackNum++
			var trackName string
			if meta.Data[0].Type == "albums" {
				trackName = fmt.Sprintf("%02d. %s", track.Attributes.TrackNumber, track.Attributes.Name)
			} else {
				trackName = fmt.Sprintf("%s - %s", track.Attributes.Name, track.Attributes.ArtistName)
			}
			data = append(data, []string{fmt.Sprint(trackNum),
				trackName,
				track.Attributes.ContentRating,
				track.Type})
		}
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"", "Track Name", "Rating", "Type"})
		table.SetRowLine(false)
		table.SetCaption(meta.Data[0].Type == "albums", fmt.Sprintf("Storefront: %s, %d tracks missing", strings.ToUpper(storefront), meta.Data[0].Attributes.TrackCount-trackTotal))
		table.SetHeaderColor(tablewriter.Colors{},
			tablewriter.Colors{tablewriter.FgRedColor, tablewriter.Bold},
			tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.Bold},
			tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.Bold})

		table.SetColumnColor(tablewriter.Colors{tablewriter.FgCyanColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgRedColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})
		for _, row := range data {
			if row[2] == "explicit" {
				row[2] = "E"
			} else if row[2] == "clean" {
				row[2] = "C"
			} else {
				row[2] = "None"
			}
			if row[3] == "music-videos" {
				row[3] = "MV"
			} else if row[3] == "songs" {
				row[3] = "SONG"
			}
			table.Append(row)
		}
		table.Render()
		fmt.Println("Please select from the track options above (multiple options separated by commas, ranges supported, or type 'all' to select all)")
		cyanColor := color.New(color.FgCyan)
		cyanColor.Print("select: ")
		reader := bufio.NewReader(os.Stdin)
		input, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println(err)
		}
		input = strings.TrimSpace(input)
		if input == "all" {
			selected = arr
		} else {
			selectedOptions := [][]string{}
			parts := strings.Split(input, ",")
			for _, part := range parts {
				if strings.Contains(part, "-") {
					rangeParts := strings.Split(part, "-")
					selectedOptions = append(selectedOptions, rangeParts)
				} else {
					selectedOptions = append(selectedOptions, []string{part})
				}
			}
			for _, opt := range selectedOptions {
				if len(opt) == 1 {
					num, err := strconv.Atoi(opt[0])
					if err != nil {
						continue
					}
					if num > 0 && num <= len(arr) {
						selected = append(selected, num)
					}
				} else if len(opt) == 2 {
					start, err1 := strconv.Atoi(opt[0])
					end, err2 := strconv.Atoi(opt[1])
					if err1 != nil || err2 != nil {
						continue
					}
					if start < 1 || end > len(arr) || start > end {
						continue
					}
					for i := start; i <= end; i++ {
						selected = append(selected, i)
					}
				}
			}
		}
	}
	return selected
}

