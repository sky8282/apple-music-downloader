package ui

import (
	"bufio"
	"errors"
	"fmt"
	"main/internal/core"
	"main/internal/utils"
	"main/utils/runv14"
	"main/utils/structs"
	"os"
	"strconv"
	"strings"
	"sync"

	"github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
	"github.com/vbauerster/mpb/v8"
	"github.com/vbauerster/mpb/v8/decor"
)

type ProgressUI struct {
	p    *mpb.Progress
	wg   *sync.WaitGroup
	bars map[int]*barState
	mu   sync.Mutex
}

type barState struct {
	bar          *mpb.Bar
	statusMsg    string
	speedStr     string
	isDecrypting bool
	statusMu     sync.Mutex
}

func NewProgressUI(wg *sync.WaitGroup) *ProgressUI {
	var p *mpb.Progress
	if wg != nil {
		p = mpb.New(mpb.WithWaitGroup(wg))
	} else {
		p = mpb.New()
	}
	return &ProgressUI{
		p:    p,
		wg:   wg,
		bars: make(map[int]*barState),
	}
}

func (pui *ProgressUI) AddTrack(trackIndex, totalTracks int, trackName, qualityStr string) {
	pui.mu.Lock()
	defer pui.mu.Unlock()

	if _, exists := pui.bars[trackIndex]; exists {
		return
	}

	prefix := fmt.Sprintf("Track %d of %d: %s", trackIndex, totalTracks, trackName)

	bs := &barState{
		statusMsg: "等待中",
		speedStr:  "",
	}

	percentageDecorator := decor.Percentage(decor.WC{W: 5})

	bar, _ := pui.p.Add(100,
		nil,
		mpb.PrependDecorators(
			decor.Name(prefix, decor.WC{W: len(prefix) + 1}),
			decor.Name(qualityStr, decor.WC{W: len(qualityStr) + 1}),
		),
		mpb.AppendDecorators(
			decor.Any(func(s decor.Statistics) string {
				bs.statusMu.Lock()
				defer bs.statusMu.Unlock()
				
				if s.Completed && !bs.isDecrypting {
					return " " + bs.statusMsg
				}
				percent, _ := percentageDecorator.Decor(s)
				spacer := " "
				status := bs.statusMsg
				speed := bs.speedStr

				if bs.isDecrypting {
					if speed != "" {
						return fmt.Sprintf(" %s (%s)", status, speed)
					} else {
						return fmt.Sprintf(" %s", status)
					}
				}

				if speed != "" {
					status = fmt.Sprintf("%s (%s)", status, speed)
				}		
				return percent + spacer + status
			}),
		),
	)

	bs.bar = bar
	pui.bars[trackIndex] = bs
}

func (pui *ProgressUI) UpdateStatus(trackIndex int, newStatus string) {
	pui.mu.Lock()
	bs, ok := pui.bars[trackIndex]
	pui.mu.Unlock()

	if ok {
		bs.statusMu.Lock()
		bs.statusMsg = newStatus
		bs.statusMu.Unlock()
	}
}

func (pui *ProgressUI) UpdateProgress(trackIndex int, percentage int, speedBPS float64) {
	pui.mu.Lock()
	bs, ok := pui.bars[trackIndex]
	pui.mu.Unlock()

	if ok {
		bs.bar.SetCurrent(int64(percentage))
		bs.statusMu.Lock()
		bs.speedStr = utils.FormatSpeed(speedBPS)
		bs.statusMu.Unlock()
	}
}

func (pui *ProgressUI) HandleProgress(trackIndex int, progressChan chan runv14.ProgressUpdate, accountName string) {
	pui.mu.Lock()
	bs, ok := pui.bars[trackIndex]
	pui.mu.Unlock()

	if !ok {
		go func() {
			for range progressChan {
			}
		}()
		return
	}

	green := color.New(color.FgGreen).SprintFunc()
	red := color.New(color.FgRed).SprintFunc()

	go func() {
		var hasStartedDecrypting bool = false

		for p := range progressChan {

			if p.Stage == "decrypt" {
				if !hasStartedDecrypting {
					hasStartedDecrypting = true
					bs.bar.SetTotal(100, false)
					bs.bar.SetCurrent(0)
				}
				bs.bar.SetCurrent(int64(p.Percentage))
				bs.statusMu.Lock()
				bs.statusMsg = red("解密中")
				bs.isDecrypting = true
				bs.speedStr = utils.FormatSpeed(p.SpeedBPS)
				bs.statusMu.Unlock()

			} else {
				hasStartedDecrypting = false
				bs.bar.SetCurrent(int64(p.Percentage))
				bs.statusMu.Lock()
				bs.isDecrypting = false
				if p.Percentage == 100 {
					bs.statusMsg = "下载完成，等待解密中"
					bs.speedStr = ""
				} else {
					bs.statusMsg = fmt.Sprintf("%s 账号下载中", green(accountName))
					bs.speedStr = utils.FormatSpeed(p.SpeedBPS)
				}
				bs.statusMu.Unlock()
			}
		}
	}()
}

func (pui *ProgressUI) SetDone(trackIndex int, status string) {
	pui.mu.Lock()
	bs, ok := pui.bars[trackIndex]
	pui.mu.Unlock()

	if ok {
		bs.statusMu.Lock()

		green := color.New(color.FgGreen).SprintFunc()
		if status == "下载完成" || status == "重编码完成" || status == "已存在" {
			bs.statusMsg = green(status)
		} else {
			bs.statusMsg = status
		}
		bs.isDecrypting = false

		bs.statusMu.Unlock()
		bs.bar.SetTotal(100, true)
	}
}

func (pui *ProgressUI) Abort(trackIndex int, status string) {
	pui.mu.Lock()
	bs, ok := pui.bars[trackIndex]
	pui.mu.Unlock()

	if ok {
		bs.statusMu.Lock()
		bs.statusMsg = status
		bs.isDecrypting = false
		bs.statusMu.Unlock()
		bs.bar.Abort(false)
	}
}

func (pui *ProgressUI) Wait() {
	pui.p.Wait()
}

func SelectTracks(meta *structs.AutoGenerated, storefront, urlArg_i string) []int {
	trackTotal := len(meta.Data[0].Relationships.Tracks.Data)
	arr := make([]int, trackTotal)
	for i := 0; i < trackTotal; i++ {
		arr[i] = i + 1
	}
	selected := []int{}

	if core.Dl_song {
		found := false
		for i, track := range meta.Data[0].Relationships.Tracks.Data {
			if urlArg_i == track.ID {
				selected = append(selected, i+1)
				found = true
				break
			}
		}
		if !found {
			fmt.Println(errors.New("指定的单曲ID未在专辑中找到"))
			return nil
		}
	} else if !core.Dl_select {
		selected = arr
	} else {
		var data [][]string
		for trackNum, track := range meta.Data[0].Relationships.Tracks.Data {
			trackNum++
			var trackName string
			if meta.Data[0].Type == "albums" {
				trackName = fmt.Sprintf("%02d. %s", track.Attributes.TrackNumber, track.Attributes.Name)
			} else {
				trackName = fmt.Sprintf("%s - %s", track.Attributes.Name, track.Attributes.ArtistName)
			}
			data = append(data, []string{fmt.Sprint(trackNum),
				trackName,
				track.Attributes.ContentRating,
				track.Type})
		}
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"", "Track Name", "Rating", "Type"})
		table.SetRowLine(false)
		table.SetCaption(meta.Data[0].Type == "albums", fmt.Sprintf("Storefront: %s, %d tracks missing", strings.ToUpper(storefront), meta.Data[0].Attributes.TrackCount-trackTotal))
		table.SetHeaderColor(tablewriter.Colors{},
			tablewriter.Colors{tablewriter.FgRedColor, tablewriter.Bold},
			tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.Bold},
			tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.Bold})

		table.SetColumnColor(tablewriter.Colors{tablewriter.FgCyanColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgRedColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})
		for _, row := range data {
			if row[2] == "explicit" {
				row[2] = "E"
			} else if row[2] == "clean" {
				row[2] = "C"
			} else {
				row[2] = "None"
			}
			if row[3] == "music-videos" {
				row[3] = "MV"
			} else if row[3] == "songs" {
				row[3] = "SONG"
			}
			table.Append(row)
		}
		table.Render()
		fmt.Println("Please select from the track options above (multiple options separated by commas, ranges supported, or type 'all' to select all)")
		cyanColor := color.New(color.FgCyan)
		cyanColor.Print("select: ")
		reader := bufio.NewReader(os.Stdin)
		input, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println(err)
		}
		input = strings.TrimSpace(input)
		if input == "all" {
			selected = arr
		} else {
			selectedOptions := [][]string{}
			parts := strings.Split(input, ",")
			for _, part := range parts {
				if strings.Contains(part, "-") {
					rangeParts := strings.Split(part, "-")
					selectedOptions = append(selectedOptions, rangeParts)
				} else {
					selectedOptions = append(selectedOptions, []string{part})
				}
			}
			for _, opt := range selectedOptions {
				if len(opt) == 1 {
					num, err := strconv.Atoi(opt[0])
					if err != nil {
						continue
					}
					if num > 0 && num <= len(arr) {
						selected = append(selected, num)
					}
				} else if len(opt) == 2 {
					start, err1 := strconv.Atoi(opt[0])
					end, err2 := strconv.Atoi(opt[1])
					if err1 != nil || err2 != nil {
						continue
					}
					if start < 1 || end > len(arr) || start > end {
						continue
					}
					for i := start; i <= end; i++ {
						selected = append(selected, i)
					}
				}
			}
		}
	}
	return selected
}
